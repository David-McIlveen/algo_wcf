#ifndef TILE_PARSER
#define TILE_PARSER

#include <filesystem>
#include <vector>
#include <map>
#include "tile.hpp"
#include "raw_tile_data.hpp"

namespace fs = std::filesystem;

class TileParser{
    public:
        TileParser(fs::path image, fs::path config);
        // Gets the tiles generated by the parser, errors if not set up yet and called
        std::vector<Tile>* get_tiles();
        bool*** get_ruleset();
        // We need to delete tiles and master_ruleset;
        ~TileParser();
    private:
        // The series of completed tiles from 0 to T - 1
        std::vector<Tile>* tiles = nullptr;
        // A crude way of checking to see if the color data does or does not exist already, not perfect but passable
        double get_color_crc(double* vals);
        int _tile_x_size;
        int _tile_y_size;
        int _tile_c_size;
        // A calculated sized of the tiles for a given image (tile_x % img_size_x * tile_y % img_size_y), an ID representation of the images, from 0 to T
        int* _id_grid;
        // A map of color data for easy lookup and to check if a tile already exists.
        std::map<double, raw_tile_data*> _data_map;
        // If it doesn't exist, add it to the vector, if it does check the id and add it to the id grid.
        std::vector<raw_tile_data*> _raw_tiles;
        // Chop up image and parse color data, assigning IDs to a grid as we go
        void parse_tiles();
        // Uses the _id_grid that was generated by parse_tiles() to determine what the rule sets are
        // TODO: ONCE THIS IS DONE, DELETE _id_grid!!!
        void set_ruleset();
        // A T * 4 * T Matrix of all the rules set by the set_ruleset function and passes to each raw data tile
        bool*** _master_ruleset;
        // Iterates though raw tiles and ruleset and assebles _tiles
        void generate_tiles();
};

#endif